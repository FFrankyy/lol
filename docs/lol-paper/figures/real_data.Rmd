---
title: "PLS vs. LOL"
author: "Eric Bridgeford"
date: "March 12, 2018"
output: html_document
---

```{r, message=FALSE}
require(lolR)
require(ggplot2)
require(latex2exp)
require(MASS)
require(gridExtra)
require(data.table)
require(reshape2)
require(R.matlab)
require(grid)
require(plyr)
require(slb)
require(scales)
require(stringr)
require(ggbeeswarm)
classifier.name <- "lda"
opath <- './data/real_data'
repo.name <- "uci"

# compute the cutoff for the particular trial to get an approximate elbow
# by computing the smallest r with an associated lhat within 5%
# of the global minimum lhat
compute_cutoff <- function(rs, lhats, t=0.05) {
  rs <- rs[complete.cases(lhats) & complete.cases(rs)]; lhats <- lhats[complete.cases(lhats) & complete.cases(rs)]
  sr.ix <- sort(rs, decreasing=FALSE, index.return=TRUE)$ix
  # compute minimum value
  min.lhat <- min(lhats)
  # compute minimum value + 5%
  lhat.thresh <- (1 + t)*min.lhat
  # find which indices are all below this
  lhat.below <- which(lhats <= lhat.thresh)
  rs.below <- rs[lhat.below]; lhats.below <- lhats[lhat.below]
  tmin.ix <- min(rs.below, index.return=TRUE)
  return(list(r=rs.below[tmin.ix], lhat=lhats.below[tmin.ix]))
}

w=.8
h=.2
plot_sim_lhats <- function(data, data.full, cols, pt.dat, linetype, shape, title="", from=10, ylab=TeX("$\\hat{L}$"),
                           xlab="Embedded Dimensions", fsize=12, length.out=3) {
  lims <- c(floor(10*min(pt.dat$lhat, na.rm=TRUE))/10, ceiling(10*max(pt.dat$lhat, na.rm=TRUE))/10)
  if (is.na(sum(lims))) {
    return(ggplot())
  }
  breaks = unique(round(seq(from=lims[1], to=lims[2], length.out = length.out), digits=1))
  xlims <- c(min(data$r, na.rm=TRUE), max(data$r, na.rm=TRUE))
  xbreaks <- seq(from=from, to=xlims[2], length.out=length.out)
  plot_sims <- ggplot(data.full, aes(x=r, y=lhat, linetype=alg, shape=alg, fill=alg, color=alg)) +
    geom_smooth(size=.95) +
    scale_color_manual(values=cols, limits=names(cols),
                       guide=guide_legend(nrow=2, byrow=TRUE), name="Algorithm") +
    geom_point(data=pt.dat, size=2) +
    #geom_line(data=base::subset(data, alg == "CCA"), aes(x=r, y=lhat, group=alg, linetype color=alg), size=.75) +
    #geom_point(data=base::subset(pt.dat, alg == "CCA"), aes(x=r, y=lhat, group=alg, color=alg), size=2) +
    #geom_line(data=base::subset(data, alg != "CCA" & alg != "QOQ"), aes(x=r, y=lhat, group=alg, color=alg), size=.75) +
    #geom_point(data=base::subset(pt.dat, alg != "CCA"), aes(x=r, y=lhat, group=alg, color=alg), size=2) +
    #geom_line(data=base::subset(data, alg == "QOQ"), aes(x=r, y=lhat, group=alg, color=alg), linetype="dashed", size=.75) +
    xlab(xlab) +
    ylab(ylab) +
    ggtitle(title) +
    theme_bw() +
    scale_y_continuous(limits=lims, breaks=breaks) +
    scale_x_continuous(limits=xlims, breaks=xbreaks) +
    scale_shape_manual(values=shape, limits=names(cols),
                       guide=guide_legend(nrow=2, byrow=TRUE), name="Algorithm") +
    scale_fill_manual(values=cols, limits=names(cols),
                      guide=guide_legend(nrow=2, byrow=TRUE), name="Algorithm") +
    theme(plot.margin = unit(c(h,w,h,h), "cm")) +
    theme(legend.position="bottom", text=element_text(size=fsize))
  return(plot_sims)
}


g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}
```

# Results Loading

```{r, message=FALSE}
#results <- readRDS(file.path(opath, paste(classifier.name, "_", dataset.name, "_results.rds", sep="")))
results <- readRDS(file.path(opath, paste(classifier.name, "_results.rds", sep="")))
#results <- subset(results, repo == repo)
results <- results[complete.cases(results$lhat),]
results <- results[results$d > 200,]
results <- results[!(results$exp %in% c("splice", "promoters", "molecular-biology_promoters")),]
nan.mean <- function(x) {mean(x[!is.infinite(x)], na.rm=TRUE)}
results.means <- aggregate(lhat ~ exp + alg + r + d + n + ntrain + K, data = results, FUN = nan.mean)
random.results <- aggregate(lhat ~ exp + alg, data=subset(results, alg == "RandomGuess"), FUN=mean)
#algs <-  c("LOL", "QOQ", "PLS", "PLSOL", "PLSOLK", "CCA", "LDA", "PCA", "RP")
#acols <- c("#00FF00", "#00FF00", "#990000", "#990000", "#990000", "#AAAA55", "#000099", "#000099", "#000099")
#linestyle <- c("solid", "dashed", "solid", "dashed", "dotted", "solid", "solid", "dashed", "dotted")
algs <-  c("LOL", "PLS", "CCA", "LRLDA", "PCA", "RP")
acols <- c("#00FF00", "#990000", "#AAAA55", "#000099", "#d06900", "#800080")
linestyle <- c("solid", "dashed", "solid","solid", "solid", "solid")
names(linestyle) <- algs
names(algs) <- acols
names(acols) <- algs
#shapes <- c(21, 24, 21, 24, 23, 23, 21, 24, 23)
shapes <- c(21, 24, 21, 24, 23, 23)
names(shapes) <- algs
exp_names <- unique(as.character(results$exp))
```

# Analysis


# WRT LOL

```{r, message=FALSE}
#nan.median <- function(x) median(x, na.rm=TRUE)  
lhat.mean <- 1
#results.medians <- aggregate(lhat ~ exp + alg + r + d + n + K, data = results, FUN = nan.median)
results.optimalr <- data.frame()
results.overall <- data.frame()
for (i in 1:length(exp_names)) {
  r.max <- max(results.means[results.means$exp == as.character(exp_names[i]),]$r)
  ss.chance <- results[results$alg == "RandomGuess" & results$exp == as.character(exp_names[i]),]
  colnames(ss.chance)[colnames(ss.chance) == "lhat"] = "lhat.chance"
  for (j in 1:length(algs)) {
    tryCatch({
      alg <- as.character(algs[j])
      ss <- results[results$exp == as.character(exp_names[i]) & results$alg == algs[j],]
      ss.means <- aggregate(lhat ~ r + n + d, data=ss, FUN = nan.mean)
      rs <- ss.means$r; lhats <- ss.means$lhat
      min.result <- compute_cutoff(rs, lhats)
      r.star <- min.result$r
      ss.optimalr <- results[results$exp == exp_names[i] & results$alg == algs[j] & results$r == r.star,]
      if (alg == 'LOL') {
        r.lol <- r.star
        lol.ss <- results[results$exp == exp_names[i] & results$alg == algs[j],]
        colnames(lol.ss)[colnames(lol.ss) == "lhat"] = "lhat.lol"
        lol.optimalr <- ss.optimalr
        colnames(lol.optimalr)[colnames(lol.optimalr) == "lhat"] = "lhat.lol"
      }
      colnames(ss)[colnames(ss) == "lhat"] = "lhat.alg"
      colnames(ss.optimalr)[colnames(ss.optimalr) == "lhat"] = "lhat.alg"
      ss.merged <- merge(ss, lol.ss, by=c("exp", "fold", "n", "d", "K", "r", "ntrain", "repo", "xv"))
      ss.merged <- merge(ss.merged, ss.chance, by=c("exp", "fold", "n", "d", "K", "ntrain", "repo", "xv"), all=TRUE)
      ss.merged$rstar.norm <- (ss.merged$r.y - ss.merged$r.x)/r.max
      ss.optimalr <- merge(ss.optimalr, lol.optimalr, by=c("exp", "fold", "n", "d", "K", "ntrain", "repo", "xv"))
      ss.optimalr <- merge(ss.optimalr, ss.chance, by=c("exp", "fold", "n", "d", "K", "ntrain", "repo", "xv"), all=TRUE)
      ss.optimalr$rstar.norm <- (ss.optimalr$r.y - ss.optimalr$r.x)/r.max
      results.overall <- rbind(results.overall, ss.merged)
      results.optimalr <- rbind(results.optimalr, ss.optimalr)
    }, error=function(e) {print(NULL)})
  }
}
results.overall$lhat.norm <- (results.overall$lhat.lol - results.overall$lhat.alg)/results.overall$lhat.chance
colnames(results.overall)[colnames(results.overall) == "alg"] <- "chance"
colnames(results.overall)[colnames(results.overall) == "alg.x"] <- "alg"
results.optimalr$lhat.norm <- (results.optimalr$lhat.lol - results.optimalr$lhat.alg)/results.optimalr$lhat.chance
colnames(results.optimalr)[colnames(results.optimalr) == "alg"] <- "chance"
colnames(results.optimalr)[colnames(results.optimalr) == "alg.x"] <- "alg"
results.exp.optimalr <- aggregate(list(lhat.norm=results.optimalr$lhat.norm, lhat.alg=results.optimalr$lhat.alg,
                                       lhat.lol=results.optimalr$lhat.lol, lhat.chance=results.optimalr$lhat.chance,
                                       rstar.norm=results.optimalr$rstar.norm),
                                  by=list(exp=results.optimalr$exp, n=results.optimalr$n, K=results.optimalr$K,
                                          ntrain=results.optimalr$ntrain, d=results.optimalr$d,
                                          repo=results.optimalr$repo, rstar.norm=results.optimalr$rstar.norm,
                                          alg=results.optimalr$alg), FUN=nan.mean)
```

# Overall Plots

```{r, message=FALSE}
plots.curves <- list()
for (i in 1:length(exp_names)) {
  exp <- exp_names[i]
  data_sub <- results.means[results.means$exp == exp,]
  data_sub.full <- results[results$exp == exp,]
  pt.dat <- data.frame(x=c(), y=c())
  for (alg in unique(data_sub$alg)) {
    pt <- compute_cutoff(data_sub[data_sub$alg == alg,]$r, data_sub[data_sub$alg == alg,]$lhat)
    pt.dat <- rbind(pt.dat, data.frame(r=pt$r, lhat=pt$lhat, alg=alg))
  }
  plots.curves[[i]] <- plot_sim_lhats(data_sub, data_sub.full, acols, pt.dat, linestyle, shapes, ylab="",
                               title=sprintf("Exp %d, K=%d, n=%d, p=%d", i, data_sub[1,]$K, data_sub[1,]$n, data_sub[1,]$d), 
                               from=1, fsize = 7)
}

plot_leg <- g_legend(plots.curves[[1]])
plots <- lapply(plots.curves, function(plot) plot + theme(legend.position=NaN) + xlab(""))
plots.curves[[1]] <- plots.curves[[1]] + xlab("Embedded Dimensions") + ylab("Misclassification Rate")

#grid.arrange(arrangeGrob(grobs=plots, nrow=floor(sqrt(length(plots)))), plot_leg, nrow=1, widths=c(0.8, .15))
```


# Quadrant Plot


```{r, message=FALSE}
make_marginal_2d <- function(data, xlims, ylims, plot.title="", xl="", yl="", leg.title="",
                             legend.style=guide_legend(ncol=2, byrow=TRUE)) {
  data$exp <- factor(data$exp)
  box <- data.frame(x=c(max(xlims), mean(xlims), mean(xlims), max(xlims)),
                    y=c(max(ylims), max(ylims), mean(ylims), mean(ylims)))
  center <- ggplot(data, aes(x=rstar.norm, y=lhat.norm)) +
    geom_polygon(data=box, aes(x=x, y=y), fill='red', alpha=0.15) +
    geom_point(aes(x=rstar.norm, y=lhat.norm, shape=alg, fill=alg), alpha=0.3, size=1.2) +
    scale_fill_manual(values=acols, guide=legend.style, name=leg.title) +
    scale_shape_manual(values=shapes, guide=legend.style, name=leg.title) +
    ylab(yl) +
    xlab(xl) +
    labs(shape="Simulation", color="Algorithm") +
    ggtitle(plot.title) +
    scale_y_continuous(limits=ylims) +
    scale_x_continuous(limits=xlims) +
    theme_bw()
  center_leg <- ggplot(data, aes(x=rstar.norm, y=lhat.norm)) +
    geom_polygon(data=box, aes(x=x, y=y), fill='red', alpha=0.15) +
    geom_point(aes(x=rstar.norm, y=lhat.norm, shape=alg, fill=alg), size=2) +
    scale_fill_manual(values=acols, guide=legend.style, name=leg.title) +
    scale_shape_manual(values=shapes, guide=legend.style, name=leg.title) +
    ylab(yl) +
    xlab(xl) +
    labs(shape="Simulation", color="Algorithm") +
    ggtitle(plot.title) +
    scale_y_continuous(limits=ylims) +
    scale_x_continuous(limits=xlims) +
    theme_bw()
  leg <- g_legend(center_leg)
  center <- center + theme(legend.position=NaN)
  right <- ggplot(data, aes(x=lhat.norm, y=..scaled.., color=alg, linetype=alg)) +
    geom_density() +
    scale_color_manual(values=acols, guide=legend.style, name=leg.title) +
    scale_fill_manual(values=acols, guide=legend.style, name=leg.title) +
    scale_linetype_manual(values=linestyle, guide=legend.style, name=leg.title) +
    scale_x_continuous(limits=ylims) +
    ylab("") +
    xlab("") +
    ggtitle("") +
    theme_bw() +
    theme(legend.position=NaN) +
    coord_flip()
  top <- ggplot(data, aes(x=rstar.norm, y=..scaled.., color=alg, linetype=alg)) +
    geom_density() +
    scale_color_manual(values=acols, guide=legend.style, name=leg.title) +
    scale_linetype_manual(values=linestyle, guide=legend.style, name=leg.title) +
    scale_x_continuous(limits=xlims) +
    ylab("") +
    xlab("") +
    ggtitle("") +
    theme_bw() + 
    theme(legend.position=NaN)
  return(arrangeGrob(top, leg, center + theme(legend.position=NaN), right, ncol=2, nrow=2, widths=c(4,1.5), heights=c(2,4)))
}

grid.arrange(make_marginal_2d(subset(results.exp.optimalr, !(alg %in% c("LOL"))),
                              c(-1, 1), c(-.15, .15), plot.title="Real Data Results", leg.title="Algorithm",
                              xl="Normalized Embedding Dimension", yl="Normalized Misclassification Rate"))
```

#

```{r}
results.optimal.means <- data.frame(alg=c(), r=c(), lhat=c())
print("Optimal")
for (j in 1:length(algs)) {
  results.optimal.means <- rbind(results.optimal.means, data.frame(alg=algs[j],
                                                                   r=mean(results.optimalr$r[results.optimalr$alg == algs[j]]),
                                                                   lhat=mean(results.optimalr$lhat[results.optimalr$alg == algs[j]])))
  print(sprintf("Mean Lhat for %s: %.3f", algs[j], mean(results.optimalr$lhat[results.optimalr$alg == algs[j]])))
  print(sprintf("Mean rhat for %s: %.3f", algs[j], mean(results.optimalr$r[results.optimalr$alg == algs[j]])))
  print(sprintf("n for %s: %d", algs[j], dim(aggregate(lhat ~ alg + exp, results.optimalr[results.optimalr$alg == algs[j],], FUN=mean))[1]))
}

ggplot(results.optimal.means, aes(x=r, y=lhat, shape=alg, fill=alg)) +
    geom_point(size=2) +
    scale_fill_manual(values=acols, guide=guide_legend(ncol=2, byrow=TRUE), name="Algorithm") +
    scale_shape_manual(values=shapes, guide=guide_legend(ncol=2, byrow=TRUE), name="Algorithm") +
    ylab("Misclassification Rate") +
    xlab("Embedding Dimension") +
    labs(shape="Simulation", color="Algorithm") +
    ggtitle("Real Data Average Results") +
    scale_y_continuous(limits=c(.1, .35)) +
    scale_x_continuous(limits=c(0, 30)) +
    theme_bw()
```

# Heatmap

```{r}
rhat.test <- data.frame(x=c(), y=c(), p=c())
lhat.test <- data.frame(x=c(), y=c(), p=c())
for (i in 1:length(algs)) {
  i.ss <- results.optimalr[results.optimalr$alg == algs[i],]
  for (j in 1:length(algs)) {
    tryCatch({
      if (algs[i] == algs[j]) {
        rhat.test <- rbind(rhat.test, data.frame(x=algs[i], y=algs[j], p=NaN))
        lhat.test <- rbind(lhat.test, data.frame(x=algs[i], y=algs[j], p=NaN))
      } else {
        j.ss <- results.optimalr[results.optimalr$alg == algs[j],]
        cmp <- merge(i.ss, j.ss, by=c("exp", "fold"), all=TRUE)
        rhat.test <- rbind(rhat.test, data.frame(x=algs[j], y=algs[i], p=wilcox.test(cmp$r.x, cmp$r.y,
                                                                                     alternative = "less", paired=TRUE)$p.value))
        lhat.test <- rbind(lhat.test, data.frame(x=algs[j], y=algs[i], p=wilcox.test(cmp$lhat.x, cmp$lhat.y,
                                                                                     alternative = "less", paired=TRUE)$p.value))
      }
    }, error=function(e){NaN})
  }
}

lhat.test$x <- factor(lhat.test$x, levels = algs); lhat.test$y <- factor(lhat.test$y, levels = algs)
rhat.test$x <- factor(rhat.test$x, levels = algs); rhat.test$y <- factor(rhat.test$y, levels = algs)
rhat.test$p[rhat.test$p < .001] = .001
lhat.test$p[lhat.test$p < .001] = .001
lhat.hmap <- ggplot(lhat.test, aes(x=x, y=y, fill=p)) +
  geom_tile() +
  geom_text(aes(label = round(p, 3))) +
  scale_fill_gradientn(name=TeX("$p$-value"), trans="log", breaks=c(0.001, 0.01, 0.1, 1),
                       colours=rev(c("#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3")),
                       limits=c(0.001, 1)) +
  ggtitle(TeX("Test of whether Algorithm i < Algorithm j in $\\hat{L}$ ")) +
  xlab("Algorithm j") +
  ylab("Algorithm i")

rhat.hmap <- ggplot(rhat.test, aes(x=x, y=y, fill=p)) +
  geom_tile() +
  geom_text(aes(label = round(p, 3))) +
  scale_fill_gradientn(name=TeX("$p$-value"), trans="log", breaks=c(0.001, 0.01, 0.1, 1),
                       colours=rev(c("#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3")),
                       limits=c(0.001, 1)) +
  ggtitle(TeX("Test of whether Algorithm i < Algorithm j in $\\hat{r}$ ")) +
  xlab("Algorithm j") +
  ylab("Algorithm i")

print(lhat.hmap)
print(rhat.hmap)
```

# Per-Dataset Plots

```{r}
plot.scatter <- list()
for (i in 1:length(exp_names)) {
  data.sub.foldwise <- subset(paired.result, alg != "LOL" & exp == exp_names[i])
  plot.scatter[[i]] <- ggplot(dat=data.sub.foldwise, aes(x=alg, y=lhat, color=alg, group=alg)) +
    geom_beeswarm(alpha=0.5, size=2) +
    xlab("Algorithm") +
    scale_y_continuous(limits=c(-0.2, .15)) +
    scale_color_manual(values=acols, guide=legend.style, name="Algorithm") +
    ylab(TeX("$Mean\\left(\\frac{\\hat{L}_{LOL} - \\hat{L}_{Alg}}{\\hat{L}_{chance}}\\right)$")) +
    theme_bw()
}

```

# Overall Plots

```{r}
legend.style=guide_legend(ncol=2, byrow=TRUE)
ggplot(dat=subset(plot.normlol.results, alg != "LOL"), aes(x=alg, y=lhat, color=alg, group=alg)) +
  geom_beeswarm(alpha=0.5, size=2) +
  xlab("Algorithm") +
  scale_y_continuous(limits=c(-0.2, .15)) +
  scale_color_manual(values=acols, guide=legend.style, name="Algorithm") +
  ylab(TeX("$Mean\\left(\\frac{\\hat{L}_{LOL} - \\hat{L}_{Alg}}{\\hat{L}_{chance}}\\right)$")) +
  theme_bw()

wilcox.result <- data.frame(algi=c(), algj=c(), p=c())
for (i in 1:length(algs)) {
  i.ss <- plot.normlol.results[plot.normlol.results$alg == algs[i],]
  for (j in 1:length(algs)) {
    j.ss <- plot.normlol.results[plot.normlol.results$alg == algs[j],]
    cmp <- merge(i.ss, j.ss, by=c("exp"), all=TRUE)
    wilcox.result <- rbind(wilcox.result, data.frame(x=algs[j], y=algs[i], p=wilcox.test(cmp$lhat.mean.x, cmp$lhat.mean.y,
                                                                                         alternative = "less", exact=FALSE, paired=TRUE)$p.value))
    
  }
}
lhat.hmap <- ggplot(wilcox.result, aes(x=x, y=y, fill=p)) +
  geom_tile() +
  geom_text(aes(label = round(p, 3))) +
  scale_fill_gradientn(name=TeX("$p$-value"), trans="log", breaks=c(0.001, 0.01, 0.1, 1),
                       colours=rev(c("#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3")),
                       limits=c(0.001, 1)) +
  ggtitle(TeX("Test of whether Algorithm i < Algorithm j in $\\hat{L}$ ")) +
  xlab("Algorithm j") +
  ylab("Algorithm i")
print(lhat.hmap)
```



```{r, message=FALSE}
rs <- plot.normlol.results$r[plot.normlol.results$alg == "PLS"]
lhats <- plot.normlol.results$lhat[plot.normlol.results$alg == "PLS"]
print(sprintf("Lower-Left (r <= 0 & lhat <= 0): %.3f", sum(rs <= 0 & lhats <= 0)/length(rs)))
print(sprintf("Lower-Right (r >= 0 & lhat <= 0): %.3f", sum(rs >= 0 & lhats <= 0)/length(rs)))
print(sprintf("Top-Left (r <= 0 & lhat >= 0): %.3f", sum(rs <= 0 & lhats >= 0)/length(rs)))
print(sprintf("Top-Right (r >= 0 & lhat >= 0): %.3f", sum(rs >= 0 & lhats >= 0)/length(rs)))
print(sprintf("Center (r == 0 & lhat == 0): %.3f", sum(rs == 0 & lhats == 0)/length(rs)))
```

```{r}
pls.ss <- subset(plot.normlol.results, alg == "PLS")
chancep <- ggplot(pls.ss, aes(x=lhat.chance, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  xlab(TeX("$\\hat{L}_{chance}$")) +
  ylab("")

pp <- ggplot(pls.ss, aes(x=p, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  xlab(TeX("p")) +
  ylab("") +
  scale_x_continuous(trans=log10_trans())

np <- ggplot(pls.ss, aes(x=n, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  xlab(TeX("n")) +
  ylab("") +
  scale_x_continuous(trans=log10_trans())

npp <- ggplot(pls.ss, aes(x=np, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  xlab(TeX("n/p")) +
  ylab("") +
  scale_x_continuous(trans=log10_trans())


kp <- ggplot(pls.ss, aes(x=K, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  ylab("") +
  xlab(TeX("K"))

mp <- ggplot(pls.ss, aes(x=lhat.mean, y=lhat)) +
  geom_point(size=1.5) +
  geom_smooth(method = "loess", size = 1.5) +
  ylab("") +
  xlab(TeX("$Mean\\left(\\hat{L}_{LOL}, \\hat{L}_{PLS}\\right)$"))

pls.ss$alpha <- ifelse(pls.ss$lhat < 0, 1, 0)
pls.ss$alpha <- factor(pls.ss$alpha, levels=c(1, 0))
acols <- c("#00ff00", "#ff0000")
names(acols) <- c(1, 0)
labs.alpha <- lapply(c("$\\hat{L}_{LOL} < \\hat{L}_{PLS}$", "$\\hat{L}_{LOL} > \\hat{L}_{PLS}$"), TeX)

np_diffp <- ggplot(pls.ss, aes(x=n, y=p, color=alpha)) +
  geom_point(size=1.5) +
  scale_x_continuous(trans=log10_trans()) +
  scale_color_manual(values=acols, labels=labs.alpha,
                     name=TeX("Normalized $Mean\\left(\\frac{\\hat{L}_{LOL} - \\hat{L}_{PLS}}{\\hat{L}_{chance}}\\right)$"))

layt.mtx <- rbind(c(1, 2, 3, 7, 7, 7),
                  c(4, 5, 6, 7, 7, 7))
grid.arrange(arrangeGrob(chancep, pp, np, npp, kp, mp, np_diffp,
             left=TeX("$Mean\\left(\\frac{\\hat{L}_{LOL} - \\hat{L}_{PLS}}{\\hat{L}_{chance}}\\right)$"),
             layout_matrix=layt.mtx))
```
