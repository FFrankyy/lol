---
title: "LOL Figure 3 with LDA Classifier"
author: "Eric Bridgeford"
date: "January 5, 2017"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Figure 3 - LOL Paper

```{r, message=FALSE}
require(lol)
require(ggplot2)
require(latex2exp)
require(MASS)
require(gridExtra)
require(data.table)
require(reshape2)

local_path <- '~/Documents/research/R-fmri/lol'  # local path to the package

sim_cov_plot <- function(Sigmas, mus, priors, title="", yl="Dimension", xl="Dimension", ndim=10, nbreaks=4, legend.name=TeX("norm $\\hat{\\Sigma}$")) {
  Sigma <- lol:::lol.mvr(Sigmas, mus, priors)
  Sigma <- Sigma[1:ndim, 1:ndim]  # subset
  Sigma <- (Sigma - min(Sigma))/(max(Sigma) - min(Sigma))
  labs <- seq(from=1, to=ndim, length=4)
  sdat <- melt(Sigma)
  plot_cov <- ggplot(sdat, aes(x=Var1, y=Var2, fill=value)) +
    geom_tile() +
    ggtitle(title) +
    xlab(xl) +
    ylab(yl) +
    theme_bw() +
    scale_x_continuous(breaks=labs) +
    scale_y_reverse(breaks=labs) +
    scale_fill_gradientn(name=legend.name, colours=rev(c("#efedf5", "#bcbddc", "#756bb1")), limits=c(0, 1), breaks=c(0.0, 0.5, 1.0)) +
    theme(legend.position="bottom")
}

sim_mean_plot <- function(mus, title="", ylab="Magnitude", xlab="Dimension", ndim=10, nbreaks=4) {
  dat <- data.frame(mus[1:ndim,])
  dat <- cbind(data.frame(1:ndim), dat)
  K <- dim(mus)[2]
  ylabs <- sapply(1:K, function(k) as.character(k))
  colnames(dat) <- c("Dimension", ylabs)
  dat <- melt(dat, id="Dimension")
  xlabs <- seq(from=1, to=ndim, length=4)
  colnames(dat) <- c("Dimension", "Class", "Magnitude")
  dat$Class <- factor(dat$Class)
  plot_mean <- ggplot(dat, aes(x=Dimension, y=Magnitude, color=Class)) +
    geom_line(size=1) +
    theme_bw() +
    ggtitle(title) +
    xlab(xlab) +
    ylab(ylab) +
    scale_x_continuous(breaks=xlabs) +
    theme(legend.position="bottom")
}

plot_sim_lhats <- function(data, title="", ylab=TeX("$\\hat{L}$"), xlab="Embedded Dimensions") {
  plot_sims <- ggplot(data, aes(x=r, y=lhat, group=alg, color=alg)) +
    geom_line(size=1) +
    xlab(xlab) +
    ylab(ylab) +
    ggtitle(title) +
    theme_bw() +
    theme(legend.position="bottom") +
    labs(color="Algorithm")
  return(plot_sims)
}

g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}
```

The below code will produce the required data, which runs LOL, cPCA, PCA, and LR-CCA at the desired simulation settings. Note that this function will multi-thread natively, and took approximately 7 hours to run on a 96 core machine with $\frac{7}{8}$ of the cores active.

```{r, eval=FALSE}
source(paste(local_path, '/docs/lol-paper/figure_3_driver.R', sep=""))
```

First, we prepare the plots of subsets of the mean and covariance matrices:

```{r}
# run the simulations once to obtain some basic visualizations
n=100
# the simulations to call themselves
sims <- list(lol.sims.rtrunk, lol.sims.toep, lol.sims.rtrunk, lol.sims.fat_tails, lol.sims.qdtoep)
maxr <- c(30, 90, 30, 30, 30)
ds <- c(100, 100, 100, 1000, 100)
# additional arguments for each simulation scenario
opt_args <- list(list(), list(), list(K=3), list(rotate=TRUE), list())
sim_names = c("Trunk-2", "Toeplitz", "Trunk-3", "Fat-Tails (D=1000)", "QDA")
ndim <- c(10, 10, 10, 10, 10)

cov_plots <- list()
mean_plots <- list()
counter <- 1

for (i in 1:length(sims)) {
  simn <- do.call(sims[[i]], c(list(n, ds[i]), opt_args[[i]]))
  cov_plots[[counter]] <- sim_cov_plot(simn$Sigmas, simn$mus, simn$priors, title=sim_names[i])
  mean_plots[[counter]] <- sim_mean_plot(simn$mus, title=sim_names[i], ndim=ndim[i])
  counter <- counter + 1
}
```

Next, we aggregate over the respective iterations, and subset plots for each function:

```{r}
# read the results in
results <- readRDS(paste(local_path, '/docs/lol-paper/lol_fig3_lda.rds', sep=""))
results.means <- results$means

sim_plots <- list()
counter <- 1
for (sim in unique(results.means$sim)) {
  data_sub <- results.means[results.means$sim == sim,]
  sim_plots[[counter]] <- plot_sim_lhats(data_sub, ylab=sim)
  counter <- counter + 1
}
```

We merge and combine the plots:

```{r, fig.show='hide'}
nsim <- length(sim_names)
sim_leg <- g_legend(sim_plots[[1]])
cov_leg <- g_legend(cov_plots[[1]])
mean_leg <- g_legend(mean_plots[[3]])

# remove the legends from the plots
sim_plots <- sapply(1:length(sim_plots), function(j) {
    resp <- sim_plots[[j]] + ggtitle("") +theme(legend.position=NaN)
    # remove the ylabel of only the non-left most columns
    if (j != 1) {
      resp <- resp + xlab("")
    }
    return(resp)
  }, simplify=FALSE)
mean_plots <- sapply(1:length(mean_plots), function(j) {
    resp <- mean_plots[[j]] + ggtitle("") + theme(legend.position=NaN)
    # remove the ylabel of only the non-left most columns
    if (j != 1) {
      resp <- resp + xlab("") + ylab("")
    }
    return(resp)
  }, simplify=FALSE)

cov_plots <- sapply(1:length(cov_plots), function(j) {
    resp <- cov_plots[[j]] + ggtitle("") + theme(legend.position=NaN)
    # remove the ylabel of only the non-left most columns
    if (j != 1) {
      resp <- resp + xlab("") + ylab("")
    }
    return(resp)
  }, simplify=FALSE)

grid_sim <- grid.arrange(grid.arrange(grobs=sim_plots, nrow=nsim), sim_leg, nrow=2, heights=c(.95, .05), top="Misclassification Rate\n")
grid_mean <- grid.arrange(grid.arrange(grobs=mean_plots, nrow=nsim), mean_leg, nrow=2, heights=c(.95, .05), top="Means\n(First 10 Dimensions)")
grid_cov <- grid.arrange(grid.arrange(grobs=cov_plots, nrow=nsim), cov_leg, nrow=2, heights=c(.95, .05), top="Covariances\n(First 10 Dimensions)")
```

We combine and plot:

```{r, fig.height=10, fig.width=8}
grid.arrange(grid_sim, grid_mean, grid_cov, ncol=3, widths=c(0.35, 0.35, 0.25))
```
